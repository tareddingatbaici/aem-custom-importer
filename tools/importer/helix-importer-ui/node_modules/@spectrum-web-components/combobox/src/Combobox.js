"use strict";var u=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var n=(p,o,e,t)=>{for(var i=t>1?void 0:t?v(o,e):o,s=p.length-1,r;s>=0;s--)(r=p[s])&&(i=(t?r(o,e,i):r(i))||i);return t&&i&&u(o,e,i),i};import{html as l}from"@spectrum-web-components/base";import{property as c,query as h,state as d}from"@spectrum-web-components/base/src/decorators.js";import{ifDefined as a,live as m,repeat as f}from"@spectrum-web-components/base/src/directives.js";import"@spectrum-web-components/overlay/sp-overlay.js";import"@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js";import"@spectrum-web-components/popover/sp-popover.js";import"@spectrum-web-components/menu/sp-menu.js";import"@spectrum-web-components/menu/sp-menu-item.js";import"@spectrum-web-components/picker-button/sp-picker-button.js";import{Textfield as b}from"@spectrum-web-components/textfield";import $ from"./combobox.css.js";import y from"@spectrum-web-components/icon/src/spectrum-icon-chevron.css.js";export class Combobox extends b{constructor(){super(...arguments);this.autocomplete="none";this.availableOptions=[];this.open=!1;this.overlayOpen=!1;this.itemValue="";this.optionEls=[];this.applyFocusElementLabel=e=>{this.appliedLabel=e};this._returnItems=()=>{}}static get styles(){return[...super.styles,$,y]}focus(){this.focusElement.focus()}click(){this.focus(),this.focusElement.click()}scrollToActiveDescendant(){var t;const e=this.shadowRoot.querySelector(`#${(t=this.activeDescendant)==null?void 0:t.value}`);e&&e.scrollIntoView({block:"nearest"})}handleComboboxKeydown(e){if(!this.readonly)if(e.altKey&&e.code==="ArrowDown")this.open=!0;else if(e.code==="ArrowDown")e.preventDefault(),this.open=!0,this.activateNextDescendant(),this.scrollToActiveDescendant();else if(e.code==="ArrowUp")e.preventDefault(),this.open=!0,this.activatePreviousDescendant(),this.scrollToActiveDescendant();else if(e.code==="Escape")this.open||(this.value=""),this.open=!1;else if(e.code==="Enter")this.selectDescendant(),this.open=!1;else if(e.code==="Home")this.focusElement.setSelectionRange(0,0),this.activeDescendant=void 0;else if(e.code==="End"){const{length:t}=this.value;this.focusElement.setSelectionRange(t,t),this.activeDescendant=void 0}else e.code==="ArrowLeft"?this.activeDescendant=void 0:e.code==="ArrowRight"&&(this.activeDescendant=void 0)}handleSlotchange(){this.setOptionsFromSlottedItems(),this.itemObserver.disconnect(),this.optionEls.map(e=>{this.itemObserver.observe(e,{attributes:!0,attributeFilter:["id"],childList:!0})})}handleTooltipSlotchange(e){this.tooltipEl=e.target.assignedElements()[0]}setOptionsFromSlottedItems(){const e=this.optionSlot.assignedElements({flatten:!0});this.optionEls=e}activateNextDescendant(){const e=this.activeDescendant?this.availableOptions.indexOf(this.activeDescendant):-1,t=(this.availableOptions.length+e+1)%this.availableOptions.length;this.activeDescendant=this.availableOptions[t]}activatePreviousDescendant(){const e=this.activeDescendant?this.availableOptions.indexOf(this.activeDescendant):0,t=(this.availableOptions.length+e-1)%this.availableOptions.length;this.activeDescendant=this.availableOptions[t]}selectDescendant(){this.activeDescendant&&(this.value=this.activeDescendant.itemText)}filterAvailableOptions(){if(this.autocomplete==="none")return;const e=this.value.toLowerCase();this.availableOptions=(this.options||this.optionEls).filter(t=>t.itemText.toLowerCase().startsWith(e))}handleInput(e){super.handleInput(e),this.activeDescendant=void 0,this.open=!0}handleMenuChange(e){const{target:t}=e,i=t.selected[0],s=(this.options||this.optionEls).find(r=>r.value===i);this.value=(s==null?void 0:s.itemText)||"",e.preventDefault(),this.open=!1,this._returnItems(),this.focus()}handleClosed(){this.open=!1,this.overlayOpen=!1}handleOpened(){}toggleOpen(){if(this.readonly){this.open=!1;return}this.open=!this.open,this.inputElement.focus()}shouldUpdate(e){var t,i;return e.has("open")&&(this.open?this.overlayOpen=!0:this.activeDescendant=void 0),e.has("value")&&(this.filterAvailableOptions(),this.itemValue=(i=(t=this.availableOptions.find(s=>s.itemText===this.value))==null?void 0:t.value)!=null?i:""),super.shouldUpdate(e)}onBlur(e){e.relatedTarget&&(this.contains(e.relatedTarget)||this.shadowRoot.contains(e.relatedTarget))||super.onBlur(e)}renderAppliedLabel(){const e=this.label||this.appliedLabel;return l`
            ${this.value?l`
                      <span
                          aria-hidden="true"
                          class="visually-hidden"
                          id="applied-label"
                      >
                          ${e}
                      </span>
                      <slot name="label" id="label">
                          <span class="visually-hidden" aria-hidden="true">
                              ${this.value}
                          </span>
                      </slot>
                  `:l`
                      <span hidden id="applied-label">${e}</span>
                  `}
        `}renderField(){return l`
            ${this.renderStateIcons()}
            <input
                aria-activedescendant=${a(this.activeDescendant?`${this.activeDescendant.value}`:void 0)}
                aria-autocomplete=${a(this.autocomplete)}
                aria-controls=${a(this.open?"listbox-menu":void 0)}
                aria-describedby="${this.helpTextId} tooltip"
                aria-expanded="${this.open?"true":"false"}"
                aria-label=${a(this.label||this.appliedLabel)}
                aria-labelledby="applied-label label"
                aria-invalid=${a(this.invalid||void 0)}
                autocomplete="off"
                @click=${this.toggleOpen}
                @keydown=${this.handleComboboxKeydown}
                id="input"
                class="input"
                role="combobox"
                type="text"
                .value=${m(this.displayValue)}
                tabindex="0"
                @sp-closed=${this.handleClosed}
                @sp-opened=${this.handleOpened}
                maxlength=${a(this.maxlength>-1?this.maxlength:void 0)}
                minlength=${a(this.minlength>-1?this.minlength:void 0)}
                pattern=${a(this.pattern)}
                @change=${this.handleChange}
                @input=${this.handleInput}
                @focus=${this.onFocus}
                @blur=${this.onBlur}
                ?disabled=${this.disabled}
                ?required=${this.required}
                ?readonly=${this.readonly}
            />
        `}render(){const e=(this.input||this).offsetWidth;return this.tooltipEl&&(this.tooltipEl.disabled=this.open),l`
            ${super.render()}
            <sp-picker-button
                aria-controls="listbox-menu"
                aria-describedby="${this.helpTextId} tooltip"
                aria-expanded=${this.open?"true":"false"}
                aria-label=${a(this.label||this.appliedLabel)}
                aria-labelledby="applied-label label"
                @click=${this.toggleOpen}
                tabindex="-1"
                class="button ${this.focused?"focus-visible is-keyboardFocused":""}"
                ?disabled=${this.disabled}
                ?focused=${this.focused}
                size=${this.size}
            ></sp-picker-button>
            <sp-overlay
                ?open=${this.open}
                .triggerElement=${this.input}
                offset="0"
                placement="bottom-start"
                .receivesFocus=${"false"}
                role="presentation"
            >
                <sp-popover
                    id="listbox"
                    ?open=${this.open}
                    role="presentation"
                    ?hidden=${this.availableOptions.length===0}
                >
                    <sp-menu
                        @change=${this.handleMenuChange}
                        tabindex="-1"
                        aria-labelledby="label applied-label"
                        aria-label=${a(this.label||this.appliedLabel)}
                        id="listbox-menu"
                        role="listbox"
                        selects=${a(this.autocomplete==="none"?"single":void 0)}
                        .selected=${this.autocomplete==="none"&&this.itemValue?[this.itemValue]:[]}
                        style="min-width: ${e}px;"
                        size=${this.size}
                    >
                        ${this.overlayOpen?f(this.availableOptions,t=>t.value,t=>{var i,s;return l`
                                          <sp-menu-item
                                              id="${t.value}"
                                              ?focused=${((i=this.activeDescendant)==null?void 0:i.value)===t.value}
                                              aria-selected=${((s=this.activeDescendant)==null?void 0:s.value)===t.value?"true":"false"}
                                              .value=${t.value}
                                          >
                                              ${t.itemText}
                                          </sp-menu-item>
                                      `}):l``}
                        <slot
                            hidden
                            @slotchange=${this.handleSlotchange}
                        ></slot>
                    </sp-menu>
                </sp-popover>
            </sp-overlay>
            ${this.renderAppliedLabel()}
            <slot
                aria-hidden="true"
                name="tooltip"
                id="tooltip"
                @slotchange=${this.handleTooltipSlotchange}
            ></slot>
        `}firstUpdated(e){super.firstUpdated(e),this.addEventListener("focusout",t=>{const i=t.relatedTarget&&this.contains(t.relatedTarget);t.target===this&&!i&&(this.focused=!1)})}async manageListOverlay(){this.open&&(this.focused=!0,this.focus())}updated(e){if(e.has("open")&&this.manageListOverlay(),!this.focused&&this.open&&(this.open=!1),e.has("activeDescendant")){const t=e.get("activeDescendant");t&&(t.focused=!1),this.activeDescendant&&typeof this.activeDescendant.focused!="undefined"&&(this.activeDescendant.focused=!0)}(e.has("options")||e.has("optionEls"))&&(this.availableOptions=this.options||this.optionEls)}async getUpdateComplete(){const e=await super.getUpdateComplete(),t=this.shadowRoot.querySelector("#listbox");if(t){const i=[...t.children];await Promise.all(i.map(s=>s.updateComplete))}return e}connectedCallback(){super.connectedCallback(),this.itemObserver||(this.itemObserver=new MutationObserver(this.setOptionsFromSlottedItems.bind(this)))}disconnectedCallback(){this.itemObserver.disconnect(),this.open=!1,super.disconnectedCallback()}}n([d()],Combobox.prototype,"activeDescendant",2),n([c({type:String})],Combobox.prototype,"autocomplete",2),n([d()],Combobox.prototype,"availableOptions",2),n([c({type:Boolean,reflect:!0})],Combobox.prototype,"open",2),n([h("slot:not([name])")],Combobox.prototype,"optionSlot",2),n([d()],Combobox.prototype,"overlayOpen",2),n([h("#input")],Combobox.prototype,"input",2),n([c({type:Array})],Combobox.prototype,"options",2),n([d()],Combobox.prototype,"optionEls",2);
//# sourceMappingURL=Combobox.js.map
