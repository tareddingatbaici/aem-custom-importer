{
  "version": 3,
  "sources": ["AbstractOverlay.ts"],
  "sourcesContent": ["/*\nCopyright 2020 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport { SpectrumElement } from '@spectrum-web-components/base';\nimport { reparentChildren } from '@spectrum-web-components/shared/src/reparent-children.js';\n\nimport type {\n    OpenableElement,\n    OverlayOptions,\n    OverlayOptionsV1,\n    OverlayState,\n    OverlayTypes,\n    Placement,\n    TriggerInteractions,\n    TriggerInteractionsV1,\n} from './overlay-types.js';\nimport type { Overlay } from './Overlay.js';\nimport type { VirtualTrigger } from './VirtualTrigger.js';\nimport { OverlayTimer } from './overlay-timer.js';\nimport type { PlacementController } from './PlacementController.js';\nimport type { ElementResolutionController } from '@spectrum-web-components/reactive-controllers/src/ElementResolution.js';\n\nexport const overlayTimer = new OverlayTimer();\n\nexport const noop = (): void => {\n    return;\n};\n\nexport class BeforetoggleClosedEvent extends Event {\n    currentState = 'open';\n    newState = 'closed';\n    constructor() {\n        super('beforetoggle', {\n            bubbles: false,\n            composed: false,\n        });\n    }\n}\n\nexport class BeforetoggleOpenEvent extends Event {\n    currentState = 'closed';\n    newState = 'open';\n    constructor() {\n        super('beforetoggle', {\n            bubbles: false,\n            composed: false,\n        });\n    }\n}\n\nexport class OverlayStateEvent extends Event {\n    detail!: {\n        interaction: string;\n        reason?: 'external-click';\n    };\n\n    constructor(\n        type: string,\n        public overlay: HTMLElement,\n        {\n            publish,\n            interaction,\n            reason,\n        }: {\n            publish?: boolean;\n            interaction: TriggerInteractions;\n            reason?: 'external-click';\n        }\n    ) {\n        super(type, {\n            bubbles: publish,\n            composed: publish,\n        });\n        this.detail = {\n            interaction,\n            reason,\n        };\n    }\n}\n\ndeclare global {\n    interface GlobalEventHandlersEventMap {\n        'sp-open': OverlayStateEvent;\n        'sp-close': OverlayStateEvent;\n    }\n}\n\n/**\n * Apply a \"transitionend\" listener to an element that may not transition but\n * guarantee the callback will be fired either way.\n *\n * @param el {HTMLElement} - Target of the \"transition\" listeners.\n * @param action {Function} - Method to trigger the \"transition\".\n * @param cb {Function} - Callback to trigger when the \"transition\" has ended.\n */\nexport const guaranteedAllTransitionend = (\n    el: HTMLElement,\n    action: () => void,\n    cb: () => void\n): void => {\n    const abortController = new AbortController();\n    const runningTransitions = new Map<string, number>();\n    const cleanup = (): void => {\n        abortController.abort();\n        cb();\n    };\n    let guarantee2: number;\n    let guarantee3: number;\n    // WebKit fires `transitionrun` a little earlier, the multiple guarantees here\n    // allow WebKit to be caught, but doesn't remove the animation listener until\n    // after it would have fired in Chromium.\n    const guarantee1 = requestAnimationFrame(() => {\n        guarantee2 = requestAnimationFrame(() => {\n            guarantee3 = requestAnimationFrame(() => {\n                cleanup();\n            });\n        });\n    });\n    const handleTransitionend = (event: TransitionEvent): void => {\n        if (event.target !== el) {\n            return;\n        }\n        runningTransitions.set(\n            event.propertyName,\n            (runningTransitions.get(event.propertyName) as number) - 1\n        );\n        if (!runningTransitions.get(event.propertyName)) {\n            runningTransitions.delete(event.propertyName);\n        }\n        if (runningTransitions.size === 0) {\n            cleanup();\n        }\n    };\n    const handleTransitionrun = (event: TransitionEvent): void => {\n        if (event.target !== el) {\n            return;\n        }\n        if (!runningTransitions.has(event.propertyName)) {\n            runningTransitions.set(event.propertyName, 0);\n        }\n        runningTransitions.set(\n            event.propertyName,\n            (runningTransitions.get(event.propertyName) as number) + 1\n        );\n        cancelAnimationFrame(guarantee1);\n        cancelAnimationFrame(guarantee2);\n        cancelAnimationFrame(guarantee3);\n    };\n    el.addEventListener('transitionrun', handleTransitionrun, {\n        signal: abortController.signal,\n    });\n    el.addEventListener('transitionend', handleTransitionend, {\n        signal: abortController.signal,\n    });\n    el.addEventListener('transitioncancel', handleTransitionend, {\n        signal: abortController.signal,\n    });\n    action();\n};\n\nexport function nextFrame(): Promise<void> {\n    return new Promise((res) => requestAnimationFrame(() => res()));\n}\n\n/**\n * Abstract Overlay base class so that property tyings and imperative API\n * interfaces can be held separate from the actual class definition.\n */\nexport class AbstractOverlay extends SpectrumElement {\n    protected async applyFocus(\n        _targetOpenState: boolean,\n        _focusEl: HTMLElement | null\n    ): Promise<void> {\n        return;\n    }\n    /* c8 ignore next 6 */\n    get delayed(): boolean {\n        return false;\n    }\n    set delayed(_delayed: boolean) {\n        return;\n    }\n    dialogEl!: HTMLDialogElement & {\n        showPopover(): void;\n        hidePopover(): void;\n    };\n    /* c8 ignore next 6 */\n    get disabled(): boolean {\n        return false;\n    }\n    set disabled(_disabled: boolean) {\n        return;\n    }\n    dispose = noop;\n    protected get elementResolver(): ElementResolutionController {\n        return this._elementResolver;\n    }\n    protected set elementResolver(controller) {\n        this._elementResolver = controller;\n    }\n    protected _elementResolver!: ElementResolutionController;\n    /* c8 ignore next 3 */\n    protected async ensureOnDOM(_targetOpenState: boolean): Promise<void> {\n        return;\n    }\n    elements!: OpenableElement[];\n    /* c8 ignore next 5 */\n    protected async makeTransition(\n        _targetOpenState: boolean\n    ): Promise<HTMLElement | null> {\n        return null;\n    }\n    protected async manageDelay(_targetOpenState: boolean): Promise<void> {\n        return;\n    }\n    /* c8 ignore next 3 */\n    protected async manageDialogOpen(): Promise<void> {\n        return;\n    }\n    /* c8 ignore next 3 */\n    protected async managePopoverOpen(): Promise<void> {\n        return;\n    }\n    /* c8 ignore next 3 */\n    protected managePosition(): void {\n        return;\n    }\n    protected offset: number | [number, number] = 0;\n    /* c8 ignore next 6 */\n    get open(): boolean {\n        return false;\n    }\n    set open(_open: boolean) {\n        return;\n    }\n    placement?: Placement;\n    protected get placementController(): PlacementController {\n        return this._placementController;\n    }\n    protected set placementController(controller) {\n        this._placementController = controller;\n    }\n    protected _placementController!: PlacementController;\n    receivesFocus!: 'true' | 'false' | 'auto';\n    protected requestSlottable(): void {}\n    protected returnFocus(): void {\n        return;\n    }\n    /* c8 ignore next 6 */\n    get state(): OverlayState {\n        return 'closed';\n    }\n    set state(_state: OverlayState) {\n        return;\n    }\n    protected _state!: OverlayState;\n    triggerElement!: HTMLElement | VirtualTrigger | null;\n    type!: OverlayTypes;\n    willPreventClose = false;\n    /* c8 ignore next 3 */\n    public manuallyKeepOpen(): void {\n        return;\n    }\n\n    public static update(): void {\n        const overlayUpdateEvent = new CustomEvent('sp-update-overlays', {\n            bubbles: true,\n            composed: true,\n            cancelable: true,\n        });\n        document.dispatchEvent(overlayUpdateEvent);\n    }\n\n    /**\n     * Overloaded imperative API entry point that allows for both the pre-0.37.0\n     * argument signature as well as the post-0.37.0 signature. This allows for\n     * consumers to continue to leverage it as they had been in previous releases\n     * while also surfacing the more feature-rich API that has been made available.\n     */\n    public static async open(\n        trigger: HTMLElement,\n        interaction: TriggerInteractionsV1,\n        content: HTMLElement,\n        optionsV1: OverlayOptionsV1\n    ): Promise<() => void>;\n    public static async open(\n        content: HTMLElement,\n        options?: OverlayOptions\n    ): Promise<Overlay>;\n    public static async open(\n        triggerOrContent: HTMLElement,\n        interactionOrOptions:\n            | TriggerInteractionsV1\n            | OverlayOptions\n            | undefined,\n        content?: HTMLElement,\n        optionsV1?: OverlayOptionsV1\n    ): Promise<Overlay | (() => void)> {\n        await import('@spectrum-web-components/overlay/sp-overlay.js');\n        const v2 = arguments.length === 2;\n        const overlayContent = content || triggerOrContent;\n        // Use the `this` from the `static` method context rather than a\n        // specific imported constructor to prevent opening a circular dependency.\n        const overlay = new this() as Overlay;\n        let restored = false;\n        overlay.dispose = () => {\n            overlay.addEventListener('sp-closed', () => {\n                if (!restored) {\n                    restoreContent();\n                    restored = true;\n                }\n                requestAnimationFrame(() => {\n                    overlay.remove();\n                });\n            });\n            overlay.open = false;\n            overlay.dispose = noop;\n        };\n        /**\n         * Since content must exist in an <sp-overlay>, we need a way to get it there.\n         * The best & most-direct way is to declaratively use an <sp-overlay> element,\n         * but for imperative users, we'll reparent content into an overlay that we've created for them.\n         **/\n        const restoreContent = reparentChildren([overlayContent], overlay, {\n            position: 'beforeend',\n            prepareCallback: (el) => {\n                // Ensure that content to be overlaid is no longer targetted to a specific `slot`.\n                // This allow for it to be visible in the overlaid context.\n                const slot = el.slot;\n                el.removeAttribute('slot');\n                return () => {\n                    el.slot = slot;\n                };\n            },\n        });\n\n        const v1 = !v2 && overlayContent && optionsV1;\n        if (v1) {\n            if (window.__swc.DEBUG) {\n                window.__swc.warn(\n                    overlay,\n                    `You are interacting with an ${overlay.localName} element via a deprecated imperative API. This API will be removed in a future version of the SWC library. Consider leveraging an ${overlay.localName} directly.`,\n                    'https://opensource.adobe.com/spectrum-web-components/components/overlay/',\n                    { level: 'deprecation' }\n                );\n            }\n            const trigger = triggerOrContent;\n            const interaction = interactionOrOptions;\n            const options = optionsV1;\n            AbstractOverlay.applyOptions(overlay, {\n                ...options,\n                delayed: options.delayed || overlayContent.hasAttribute('delayed'),\n                trigger: options.virtualTrigger || trigger,\n                type: interaction === 'modal'\n                    ? 'modal'\n                    : interaction === 'hover'\n                    ? 'hint'\n                    : 'auto'\n            });\n            trigger.insertAdjacentElement('afterend', overlay);\n            await overlay.updateComplete;\n            overlay.open = true;\n            return overlay.dispose;\n        }\n\n        const options = interactionOrOptions as OverlayOptions;\n        overlay.append(overlayContent);\n        AbstractOverlay.applyOptions(overlay, {\n            ...options,\n            delayed: options.delayed || overlayContent.hasAttribute('delayed')\n        });\n        overlay.updateComplete.then(() => {\n            // Do we want to \"open\" this path, or leave that to the consumer?\n            overlay.open = true;\n        });\n        return overlay;\n    }\n\n    static applyOptions(overlay: Overlay, options: OverlayOptions): void {\n        overlay.delayed = !!options.delayed;\n        overlay.receivesFocus = options.receivesFocus ?? 'auto';\n        overlay.triggerElement = options.trigger || null;\n        overlay.type = options.type || 'modal';\n        overlay.offset = options.offset ?? 0;\n        overlay.placement = options.placement;\n        overlay.willPreventClose = !!options.notImmediatelyClosable;\n    }\n}\n"],
  "mappings": "aAWA,OAAS,mBAAAA,MAAuB,gCAChC,OAAS,oBAAAC,MAAwB,2DAcjC,OAAS,gBAAAC,MAAoB,qBAItB,aAAM,aAAe,IAAIA,EAEnB,KAAO,IAAY,CAEhC,EAEO,aAAM,gCAAgC,KAAM,CAG/C,aAAc,CACV,MAAM,eAAgB,CAClB,QAAS,GACT,SAAU,EACd,CAAC,EANL,kBAAe,OACf,cAAW,QAMX,CACJ,CAEO,aAAM,8BAA8B,KAAM,CAG7C,aAAc,CACV,MAAM,eAAgB,CAClB,QAAS,GACT,SAAU,EACd,CAAC,EANL,kBAAe,SACf,cAAW,MAMX,CACJ,CAEO,aAAM,0BAA0B,KAAM,CAMzC,YACIC,EACOC,EACP,CACI,QAAAC,EACA,YAAAC,EACA,OAAAC,CACJ,EAKF,CACE,MAAMJ,EAAM,CACR,QAASE,EACT,SAAUA,CACd,CAAC,EAdM,aAAAD,EAeP,KAAK,OAAS,CACV,YAAAE,EACA,OAAAC,CACJ,CACJ,CACJ,CAiBO,aAAM,2BAA6B,CACtCC,EACAC,EACAC,IACO,CACP,MAAMC,EAAkB,IAAI,gBACtBC,EAAqB,IAAI,IACzBC,EAAU,IAAY,CACxBF,EAAgB,MAAM,EACtBD,EAAG,CACP,EACA,IAAII,EACAC,EAIJ,MAAMC,EAAa,sBAAsB,IAAM,CAC3CF,EAAa,sBAAsB,IAAM,CACrCC,EAAa,sBAAsB,IAAM,CACrCF,EAAQ,CACZ,CAAC,CACL,CAAC,CACL,CAAC,EACKI,EAAuBC,GAAiC,CACtDA,EAAM,SAAWV,IAGrBI,EAAmB,IACfM,EAAM,aACLN,EAAmB,IAAIM,EAAM,YAAY,EAAe,CAC7D,EACKN,EAAmB,IAAIM,EAAM,YAAY,GAC1CN,EAAmB,OAAOM,EAAM,YAAY,EAE5CN,EAAmB,OAAS,GAC5BC,EAAQ,EAEhB,EACMM,EAAuBD,GAAiC,CACtDA,EAAM,SAAWV,IAGhBI,EAAmB,IAAIM,EAAM,YAAY,GAC1CN,EAAmB,IAAIM,EAAM,aAAc,CAAC,EAEhDN,EAAmB,IACfM,EAAM,aACLN,EAAmB,IAAIM,EAAM,YAAY,EAAe,CAC7D,EACA,qBAAqBF,CAAU,EAC/B,qBAAqBF,CAAU,EAC/B,qBAAqBC,CAAU,EACnC,EACAP,EAAG,iBAAiB,gBAAiBW,EAAqB,CACtD,OAAQR,EAAgB,MAC5B,CAAC,EACDH,EAAG,iBAAiB,gBAAiBS,EAAqB,CACtD,OAAQN,EAAgB,MAC5B,CAAC,EACDH,EAAG,iBAAiB,mBAAoBS,EAAqB,CACzD,OAAQN,EAAgB,MAC5B,CAAC,EACDF,EAAO,CACX,EAEO,gBAAS,WAA2B,CACvC,OAAO,IAAI,QAASW,GAAQ,sBAAsB,IAAMA,EAAI,CAAC,CAAC,CAClE,CAMO,aAAM,wBAAwBpB,CAAgB,CAA9C,kCAyBH,aAAU,KAkCV,KAAU,OAAoC,EA+B9C,sBAAmB,GAzFnB,MAAgB,WACZqB,EACAC,EACa,CAEjB,CAEA,IAAI,SAAmB,CACnB,MAAO,EACX,CACA,IAAI,QAAQC,EAAmB,CAE/B,CAMA,IAAI,UAAoB,CACpB,MAAO,EACX,CACA,IAAI,SAASC,EAAoB,CAEjC,CAEA,IAAc,iBAA+C,CACzD,OAAO,KAAK,gBAChB,CACA,IAAc,gBAAgBC,EAAY,CACtC,KAAK,iBAAmBA,CAC5B,CAGA,MAAgB,YAAYJ,EAA0C,CAEtE,CAGA,MAAgB,eACZA,EAC2B,CAC3B,OAAO,IACX,CACA,MAAgB,YAAYA,EAA0C,CAEtE,CAEA,MAAgB,kBAAkC,CAElD,CAEA,MAAgB,mBAAmC,CAEnD,CAEU,gBAAuB,CAEjC,CAGA,IAAI,MAAgB,CAChB,MAAO,EACX,CACA,IAAI,KAAKK,EAAgB,CAEzB,CAEA,IAAc,qBAA2C,CACrD,OAAO,KAAK,oBAChB,CACA,IAAc,oBAAoBD,EAAY,CAC1C,KAAK,qBAAuBA,CAChC,CAGU,kBAAyB,CAAC,CAC1B,aAAoB,CAE9B,CAEA,IAAI,OAAsB,CACtB,MAAO,QACX,CACA,IAAI,MAAME,EAAsB,CAEhC,CAMO,kBAAyB,CAEhC,CAEA,OAAc,QAAe,CACzB,MAAMC,EAAqB,IAAI,YAAY,qBAAsB,CAC7D,QAAS,GACT,SAAU,GACV,WAAY,EAChB,CAAC,EACD,SAAS,cAAcA,CAAkB,CAC7C,CAkBA,aAAoB,KAChBC,EACAC,EAIAC,EACAC,EAC+B,CAC/B,KAAM,QAAO,gDAAgD,EAC7D,MAAMC,EAAK,UAAU,SAAW,EAC1BC,EAAiBH,GAAWF,EAG5BzB,EAAU,IAAI,KACpB,IAAI+B,EAAW,GACf/B,EAAQ,QAAU,IAAM,CACpBA,EAAQ,iBAAiB,YAAa,IAAM,CACnC+B,IACDC,EAAe,EACfD,EAAW,IAEf,sBAAsB,IAAM,CACxB/B,EAAQ,OAAO,CACnB,CAAC,CACL,CAAC,EACDA,EAAQ,KAAO,GACfA,EAAQ,QAAU,IACtB,EAMA,MAAMgC,EAAiBnC,EAAiB,CAACiC,CAAc,EAAG9B,EAAS,CAC/D,SAAU,YACV,gBAAkBI,GAAO,CAGrB,MAAM6B,EAAO7B,EAAG,KAChB,OAAAA,EAAG,gBAAgB,MAAM,EAClB,IAAM,CACTA,EAAG,KAAO6B,CACd,CACJ,CACJ,CAAC,EAGD,GADW,CAACJ,GAAMC,GAAkBF,EAC5B,CASJ,MAAMM,EAAUT,EACVvB,EAAcwB,EACdS,EAAUP,EAChB,uBAAgB,aAAa5B,EAAS,CAClC,GAAGmC,EACH,QAASA,EAAQ,SAAWL,EAAe,aAAa,SAAS,EACjE,QAASK,EAAQ,gBAAkBD,EACnC,KAAMhC,IAAgB,QAChB,QACAA,IAAgB,QAChB,OACA,MACV,CAAC,EACDgC,EAAQ,sBAAsB,WAAYlC,CAAO,EACjD,MAAMA,EAAQ,eACdA,EAAQ,KAAO,GACRA,EAAQ,OACnB,CAEA,MAAMmC,EAAUT,EAChB,OAAA1B,EAAQ,OAAO8B,CAAc,EAC7B,gBAAgB,aAAa9B,EAAS,CAClC,GAAGmC,EACH,QAASA,EAAQ,SAAWL,EAAe,aAAa,SAAS,CACrE,CAAC,EACD9B,EAAQ,eAAe,KAAK,IAAM,CAE9BA,EAAQ,KAAO,EACnB,CAAC,EACMA,CACX,CAEA,OAAO,aAAaA,EAAkBmC,EAA+B,CAlYzE,IAAAC,EAAAC,EAmYQrC,EAAQ,QAAU,CAAC,CAACmC,EAAQ,QAC5BnC,EAAQ,eAAgBoC,EAAAD,EAAQ,gBAAR,KAAAC,EAAyB,OACjDpC,EAAQ,eAAiBmC,EAAQ,SAAW,KAC5CnC,EAAQ,KAAOmC,EAAQ,MAAQ,QAC/BnC,EAAQ,QAASqC,EAAAF,EAAQ,SAAR,KAAAE,EAAkB,EACnCrC,EAAQ,UAAYmC,EAAQ,UAC5BnC,EAAQ,iBAAmB,CAAC,CAACmC,EAAQ,sBACzC,CACJ",
  "names": ["SpectrumElement", "reparentChildren", "OverlayTimer", "type", "overlay", "publish", "interaction", "reason", "el", "action", "cb", "abortController", "runningTransitions", "cleanup", "guarantee2", "guarantee3", "guarantee1", "handleTransitionend", "event", "handleTransitionrun", "res", "_targetOpenState", "_focusEl", "_delayed", "_disabled", "controller", "_open", "_state", "overlayUpdateEvent", "triggerOrContent", "interactionOrOptions", "content", "optionsV1", "v2", "overlayContent", "restored", "restoreContent", "slot", "trigger", "options", "_a", "_b"]
}
