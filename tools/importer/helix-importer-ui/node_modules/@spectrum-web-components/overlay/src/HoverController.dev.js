"use strict";
import { conditionAttributeWithId } from "@spectrum-web-components/base/src/condition-attribute-with-id.js";
import { randomID } from "@spectrum-web-components/shared/src/random-id.js";
import {
  InteractionController,
  InteractionTypes
} from "./InteractionController.dev.js";
import { noop } from "./AbstractOverlay.dev.js";
const HOVER_DELAY = 300;
export class HoverController extends InteractionController {
  constructor() {
    super(...arguments);
    this.type = InteractionTypes.hover;
    this.elementIds = [];
    this.focusedin = false;
    this.pointerentered = false;
  }
  handleTargetFocusin() {
    var _a;
    if (!((_a = document.activeElement) == null ? void 0 : _a.matches(":focus-visible"))) {
      return;
    }
    this.host.open = true;
    this.focusedin = true;
  }
  handleTargetFocusout() {
    this.focusedin = false;
    if (this.pointerentered)
      return;
    this.host.open = false;
  }
  handleTargetPointerenter() {
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = void 0;
    }
    if (this.host.disabled)
      return;
    this.host.open = true;
    this.pointerentered = true;
  }
  handleTargetPointerleave() {
    this.doPointerleave();
  }
  // set a timeout once the pointer enters and the overlay is shown
  // give the user time to enter the overlay
  handleHostPointerenter() {
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = void 0;
    }
  }
  handleHostPointerleave() {
    this.doPointerleave();
  }
  prepareDescription() {
    if (!this.host.elements.length)
      return;
    const triggerRoot = this.target.getRootNode();
    const contentRoot = this.host.elements[0].getRootNode();
    const overlayRoot = this.host.getRootNode();
    if (triggerRoot === overlayRoot) {
      this.prepareOverlayRelativeDescription();
    } else if (triggerRoot === contentRoot) {
      this.prepareContentRelativeDescription();
    }
  }
  prepareOverlayRelativeDescription() {
    const releaseDescription = conditionAttributeWithId(
      this.target,
      "aria-describedby",
      [this.host.id]
    );
    this.releaseDescription = () => {
      releaseDescription();
      this.releaseDescription = noop;
    };
  }
  prepareContentRelativeDescription() {
    const elementIds = [];
    const appliedIds = this.host.elements.map((el) => {
      elementIds.push(el.id);
      if (!el.id) {
        el.id = `${this.host.tagName.toLowerCase()}-helper-${randomID()}`;
      }
      return el.id;
    });
    this.elementIds = elementIds;
    const releaseDescription = conditionAttributeWithId(
      this.target,
      "aria-describedby",
      appliedIds
    );
    this.releaseDescription = () => {
      releaseDescription();
      this.host.elements.map((el, index) => {
        el.id = this.elementIds[index];
      });
      this.releaseDescription = noop;
    };
  }
  doPointerleave() {
    this.pointerentered = false;
    const triggerElement = this.target;
    if (this.focusedin && triggerElement.matches(":focus-visible"))
      return;
    this.hoverTimeout = setTimeout(() => {
      this.host.open = false;
    }, HOVER_DELAY);
  }
  init() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.abortController = new AbortController();
    const { signal } = this.abortController;
    this.target.addEventListener(
      "focusin",
      () => this.handleTargetFocusin(),
      { signal }
    );
    this.target.addEventListener(
      "focusout",
      () => this.handleTargetFocusout(),
      { signal }
    );
    this.target.addEventListener(
      "pointerenter",
      () => this.handleTargetPointerenter(),
      { signal }
    );
    this.target.addEventListener(
      "pointerleave",
      () => this.handleTargetPointerleave(),
      { signal }
    );
    this.host.addEventListener(
      "pointerenter",
      () => this.handleHostPointerenter(),
      { signal }
    );
    this.host.addEventListener(
      "pointerleave",
      () => this.handleHostPointerleave(),
      { signal }
    );
  }
}
//# sourceMappingURL=HoverController.dev.js.map
